(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[4],{

/***/ "./node_modules/lie/lib/index.js":
/*!***************************************!*\
  !*** ./node_modules/lie/lib/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {\nvar immediate = __webpack_require__(/*! immediate */ \"./node_modules/immediate/lib/browser.js\");\n\n/* istanbul ignore next */\nfunction INTERNAL() {}\n\nvar handlers = {};\n\nvar REJECTED = ['REJECTED'];\nvar FULFILLED = ['FULFILLED'];\nvar PENDING = ['PENDING'];\n/* istanbul ignore else */\nif (!process.browser) {\n  // in which we actually take advantage of JS scoping\n  var UNHANDLED = ['UNHANDLED'];\n}\n\nmodule.exports = Promise;\n\nfunction Promise(resolver) {\n  if (typeof resolver !== 'function') {\n    throw new TypeError('resolver must be a function');\n  }\n  this.state = PENDING;\n  this.queue = [];\n  this.outcome = void 0;\n  /* istanbul ignore else */\n  if (!process.browser) {\n    this.handled = UNHANDLED;\n  }\n  if (resolver !== INTERNAL) {\n    safelyResolveThenable(this, resolver);\n  }\n}\n\nPromise.prototype.catch = function (onRejected) {\n  return this.then(null, onRejected);\n};\nPromise.prototype.then = function (onFulfilled, onRejected) {\n  if (typeof onFulfilled !== 'function' && this.state === FULFILLED ||\n    typeof onRejected !== 'function' && this.state === REJECTED) {\n    return this;\n  }\n  var promise = new this.constructor(INTERNAL);\n  /* istanbul ignore else */\n  if (!process.browser) {\n    if (this.handled === UNHANDLED) {\n      this.handled = null;\n    }\n  }\n  if (this.state !== PENDING) {\n    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;\n    unwrap(promise, resolver, this.outcome);\n  } else {\n    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));\n  }\n\n  return promise;\n};\nfunction QueueItem(promise, onFulfilled, onRejected) {\n  this.promise = promise;\n  if (typeof onFulfilled === 'function') {\n    this.onFulfilled = onFulfilled;\n    this.callFulfilled = this.otherCallFulfilled;\n  }\n  if (typeof onRejected === 'function') {\n    this.onRejected = onRejected;\n    this.callRejected = this.otherCallRejected;\n  }\n}\nQueueItem.prototype.callFulfilled = function (value) {\n  handlers.resolve(this.promise, value);\n};\nQueueItem.prototype.otherCallFulfilled = function (value) {\n  unwrap(this.promise, this.onFulfilled, value);\n};\nQueueItem.prototype.callRejected = function (value) {\n  handlers.reject(this.promise, value);\n};\nQueueItem.prototype.otherCallRejected = function (value) {\n  unwrap(this.promise, this.onRejected, value);\n};\n\nfunction unwrap(promise, func, value) {\n  immediate(function () {\n    var returnValue;\n    try {\n      returnValue = func(value);\n    } catch (e) {\n      return handlers.reject(promise, e);\n    }\n    if (returnValue === promise) {\n      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));\n    } else {\n      handlers.resolve(promise, returnValue);\n    }\n  });\n}\n\nhandlers.resolve = function (self, value) {\n  var result = tryCatch(getThen, value);\n  if (result.status === 'error') {\n    return handlers.reject(self, result.value);\n  }\n  var thenable = result.value;\n\n  if (thenable) {\n    safelyResolveThenable(self, thenable);\n  } else {\n    self.state = FULFILLED;\n    self.outcome = value;\n    var i = -1;\n    var len = self.queue.length;\n    while (++i < len) {\n      self.queue[i].callFulfilled(value);\n    }\n  }\n  return self;\n};\nhandlers.reject = function (self, error) {\n  self.state = REJECTED;\n  self.outcome = error;\n  /* istanbul ignore else */\n  if (!process.browser) {\n    if (self.handled === UNHANDLED) {\n      immediate(function () {\n        if (self.handled === UNHANDLED) {\n          process.emit('unhandledRejection', error, self);\n        }\n      });\n    }\n  }\n  var i = -1;\n  var len = self.queue.length;\n  while (++i < len) {\n    self.queue[i].callRejected(error);\n  }\n  return self;\n};\n\nfunction getThen(obj) {\n  // Make sure we only access the accessor once as required by the spec\n  var then = obj && obj.then;\n  if (obj && typeof obj === 'object' && typeof then === 'function') {\n    return function appyThen() {\n      then.apply(obj, arguments);\n    };\n  }\n}\n\nfunction safelyResolveThenable(self, thenable) {\n  // Either fulfill, reject or reject with error\n  var called = false;\n  function onError(value) {\n    if (called) {\n      return;\n    }\n    called = true;\n    handlers.reject(self, value);\n  }\n\n  function onSuccess(value) {\n    if (called) {\n      return;\n    }\n    called = true;\n    handlers.resolve(self, value);\n  }\n\n  function tryToUnwrap() {\n    thenable(onSuccess, onError);\n  }\n\n  var result = tryCatch(tryToUnwrap);\n  if (result.status === 'error') {\n    onError(result.value);\n  }\n}\n\nfunction tryCatch(func, value) {\n  var out = {};\n  try {\n    out.value = func(value);\n    out.status = 'success';\n  } catch (e) {\n    out.status = 'error';\n    out.value = e;\n  }\n  return out;\n}\n\nPromise.resolve = resolve;\nfunction resolve(value) {\n  if (value instanceof this) {\n    return value;\n  }\n  return handlers.resolve(new this(INTERNAL), value);\n}\n\nPromise.reject = reject;\nfunction reject(reason) {\n  var promise = new this(INTERNAL);\n  return handlers.reject(promise, reason);\n}\n\nPromise.all = all;\nfunction all(iterable) {\n  var self = this;\n  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n    return this.reject(new TypeError('must be an array'));\n  }\n\n  var len = iterable.length;\n  var called = false;\n  if (!len) {\n    return this.resolve([]);\n  }\n\n  var values = new Array(len);\n  var resolved = 0;\n  var i = -1;\n  var promise = new this(INTERNAL);\n\n  while (++i < len) {\n    allResolver(iterable[i], i);\n  }\n  return promise;\n  function allResolver(value, i) {\n    self.resolve(value).then(resolveFromAll, function (error) {\n      if (!called) {\n        called = true;\n        handlers.reject(promise, error);\n      }\n    });\n    function resolveFromAll(outValue) {\n      values[i] = outValue;\n      if (++resolved === len && !called) {\n        called = true;\n        handlers.resolve(promise, values);\n      }\n    }\n  }\n}\n\nPromise.race = race;\nfunction race(iterable) {\n  var self = this;\n  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n    return this.reject(new TypeError('must be an array'));\n  }\n\n  var len = iterable.length;\n  var called = false;\n  if (!len) {\n    return this.resolve([]);\n  }\n\n  var i = -1;\n  var promise = new this(INTERNAL);\n\n  while (++i < len) {\n    resolver(iterable[i]);\n  }\n  return promise;\n  function resolver(value) {\n    self.resolve(value).then(function (response) {\n      if (!called) {\n        called = true;\n        handlers.resolve(promise, response);\n      }\n    }, function (error) {\n      if (!called) {\n        called = true;\n        handlers.reject(promise, error);\n      }\n    });\n  }\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/lie/lib/index.js?");

/***/ }),

/***/ "./node_modules/pouchdb-extend/index.js":
/*!**********************************************!*\
  !*** ./node_modules/pouchdb-extend/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// Extends method\n// (taken from http://code.jquery.com/jquery-1.9.0.js)\n// Populate the class2type map\nvar class2type = {};\n\nvar types = [\n  \"Boolean\", \"Number\", \"String\", \"Function\", \"Array\",\n  \"Date\", \"RegExp\", \"Object\", \"Error\"\n];\nfor (var i = 0; i < types.length; i++) {\n  var typename = types[i];\n  class2type[\"[object \" + typename + \"]\"] = typename.toLowerCase();\n}\n\nvar core_toString = class2type.toString;\nvar core_hasOwn = class2type.hasOwnProperty;\n\nfunction type(obj) {\n  if (obj === null) {\n    return String(obj);\n  }\n  return typeof obj === \"object\" || typeof obj === \"function\" ?\n    class2type[core_toString.call(obj)] || \"object\" :\n    typeof obj;\n}\n\nfunction isWindow(obj) {\n  return obj !== null && obj === obj.window;\n}\n\nfunction isPlainObject(obj) {\n  // Must be an Object.\n  // Because of IE, we also have to check the presence of\n  // the constructor property.\n  // Make sure that DOM nodes and window objects don't pass through, as well\n  if (!obj || type(obj) !== \"object\" || obj.nodeType || isWindow(obj)) {\n    return false;\n  }\n\n  try {\n    // Not own constructor property must be Object\n    if (obj.constructor &&\n      !core_hasOwn.call(obj, \"constructor\") &&\n      !core_hasOwn.call(obj.constructor.prototype, \"isPrototypeOf\")) {\n      return false;\n    }\n  } catch ( e ) {\n    // IE8,9 Will throw exceptions on certain host objects #9897\n    return false;\n  }\n\n  // Own properties are enumerated firstly, so to speed up,\n  // if last one is own, then all properties are own.\n  var key;\n  for (key in obj) {}\n\n  return key === undefined || core_hasOwn.call(obj, key);\n}\n\n\nfunction isFunction(obj) {\n  return type(obj) === \"function\";\n}\n\nvar isArray = Array.isArray || function (obj) {\n  return type(obj) === \"array\";\n};\n\nfunction extend() {\n  // originally extend() was recursive, but this ended up giving us\n  // \"call stack exceeded\", so it's been unrolled to use a literal stack\n  // (see https://github.com/pouchdb/pouchdb/issues/2543)\n  var stack = [];\n  var i = -1;\n  var len = arguments.length;\n  var args = new Array(len);\n  while (++i < len) {\n    args[i] = arguments[i];\n  }\n  var container = {};\n  stack.push({args: args, result: {container: container, key: 'key'}});\n  var next;\n  while ((next = stack.pop())) {\n    extendInner(stack, next.args, next.result);\n  }\n  return container.key;\n}\n\nfunction extendInner(stack, args, result) {\n  var options, name, src, copy, copyIsArray, clone,\n    target = args[0] || {},\n    i = 1,\n    length = args.length,\n    deep = false,\n    numericStringRegex = /\\d+/,\n    optionsIsArray;\n\n  // Handle a deep copy situation\n  if (typeof target === \"boolean\") {\n    deep = target;\n    target = args[1] || {};\n    // skip the boolean and the target\n    i = 2;\n  }\n\n  // Handle case when target is a string or something (possible in deep copy)\n  if (typeof target !== \"object\" && !isFunction(target)) {\n    target = {};\n  }\n\n  // extend jQuery itself if only one argument is passed\n  if (length === i) {\n    /* jshint validthis: true */\n    target = this;\n    --i;\n  }\n\n  for (; i < length; i++) {\n    // Only deal with non-null/undefined values\n    if ((options = args[i]) != null) {\n      optionsIsArray = isArray(options);\n      // Extend the base object\n      for (name in options) {\n        //if (options.hasOwnProperty(name)) {\n        if (!(name in Object.prototype)) {\n          if (optionsIsArray && !numericStringRegex.test(name)) {\n            continue;\n          }\n\n          src = target[name];\n          copy = options[name];\n\n          // Prevent never-ending loop\n          if (target === copy) {\n            continue;\n          }\n\n          // Recurse if we're merging plain objects or arrays\n          if (deep && copy && (isPlainObject(copy) ||\n              (copyIsArray = isArray(copy)))) {\n            if (copyIsArray) {\n              copyIsArray = false;\n              clone = src && isArray(src) ? src : [];\n\n            } else {\n              clone = src && isPlainObject(src) ? src : {};\n            }\n\n            // Never move original objects, clone them\n            stack.push({\n              args: [deep, clone, copy],\n              result: {\n                container: target,\n                key: name\n              }\n            });\n\n          // Don't bring in undefined values\n          } else if (copy !== undefined) {\n            if (!(isArray(options) && isFunction(copy))) {\n              target[name] = copy;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // \"Return\" the modified object by setting the key\n  // on the given container\n  result.container[result.key] = target;\n}\n\n\nmodule.exports = extend;\n\n\n\n\n//# sourceURL=webpack:///./node_modules/pouchdb-extend/index.js?");

/***/ }),

/***/ "./node_modules/pouchdb-wrappers/index.js":
/*!************************************************!*\
  !*** ./node_modules/pouchdb-wrappers/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\n    Copyright 2014-2015, Marten de Vries\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\n\n\nvar nodify = __webpack_require__(/*! promise-nodify */ \"./node_modules/promise-nodify/index.js\");\n\nexports.installStaticWrapperMethods = function (PouchDB, handlers) {\n  //set an 'alternative constructor' so the constructor can be easily\n  //wrapped, since wrapping 'real' constructors is hard.\n  PouchDB.new = PouchDB.new || function (name, options, callback) {\n    return new PouchDB(name, options, callback);\n  };\n  PouchDB.destroy = PouchDB.destroy || function (name, options, callback) {\n    var args = parseBaseArgs(PouchDB, this, options, callback);\n    var db = new PouchDB(name, args.options);\n    var promise = db.destroy();\n    nodify(promise, args.callback);\n    return promise;\n  };\n\n  installWrappers(PouchDB, handlers, exports.createStaticWrapperMethod);\n};\n\nexports.installWrapperMethods = function (db, handlers) {\n  installWrappers(db, handlers, exports.createWrapperMethod);\n};\n\nfunction installWrappers(base, handlers, createWrapperMethod) {\n  for (var name in handlers) {\n    if (!handlers.hasOwnProperty(name)) {\n      continue;\n    }\n    var info = getBaseAndName(base, name);\n    var original = info.base[info.name];\n    if (!original) {\n      //no method to wrap\n      continue;\n    }\n    if (original.hasOwnProperty(\"_handlers\")) {\n      if (original._handlers.indexOf(handlers[name]) !== -1) {\n        throw new Error(\"Wrapper method for '\" + name + \"' already installed: \" + handlers[name]);\n      }\n      original._handlers.push(handlers[name]);\n    } else {\n      info.base[info.name] = createWrapperMethod(name, original, handlers[name], base);\n    }\n  }\n}\n\nfunction getBaseAndName(base, name) {\n  name = name.split(\".\");\n  while (name.length > 1) {\n    base = base[name.shift(0)];\n  }\n  return {\n    base: base,\n    name: name[0]\n  };\n}\n\nexports.createStaticWrapperMethod = function (name, original, handler, PouchDB) {\n  //PouchDB is optional\n  return createWrapper(name, original, handler, staticWrapperBuilders, PouchDB);\n};\n\nexports.createWrapperMethod = function (name, original, handler, db) {\n  //db is optional\n  return createWrapper(name, original, handler, wrapperBuilders, db);\n};\n\nfunction createWrapper(name, original, handler, theWrapperBuilders, thisVal) {\n  //thisVal is optional\n  var buildWrapper = theWrapperBuilders[name];\n  if (typeof createWrapper === \"undefined\") {\n    throw new Error(\"No known wrapper for method name: \" + name); //coverage: ignore\n  }\n  var handlers = [handler];\n  var wrapper = buildWrapper(thisVal, original, handlers);\n  wrapper._original = original;\n  wrapper._handlers = handlers;\n  return wrapper;\n}\n\nvar wrapperBuilders = {};\n\nwrapperBuilders.destroy = function (db, destroy, handlers) {\n  return function (options, callback) {\n    var args = parseBaseArgs(db, this, options, callback);\n    return callHandlers(handlers, args, makeCall(destroy));\n  };\n};\n\nwrapperBuilders.put = function (db, put, handlers) {\n  return function (doc, docId, docRev, options, callback) {\n    var args = {};\n    args.base = db || this;\n    args.db = db || this; //backwards compatibility\n    var argsList = Array.prototype.slice.call(arguments);\n    //parsing code borrowed from PouchDB (adapted).\n    args.doc = argsList.shift();\n    var id = '_id' in args.doc;\n    while (true) {\n      var temp = argsList.shift();\n      var temptype = typeof temp;\n      if (temptype === \"string\" && !id) {\n        args.doc._id = temp;\n        id = true;\n      } else if (temptype === \"string\" && id && !('_rev' in args.doc)) {\n        args.doc._rev = temp;\n      } else if (temptype === \"object\") {\n        args.options = temp;\n      } else if (temptype === \"function\") {\n        args.callback = temp;\n      }\n      if (!argsList.length) {\n        break;\n      }\n    }\n    args.options = args.options || {};\n    return callHandlers(handlers, args, function () {\n      return put.call(this, args.doc, args.options);\n    });\n  };\n};\n\nwrapperBuilders.post = function (db, post, handlers) {\n  return function (doc, options, callback) {\n    var args = parseBaseArgs(db, this, options, callback);\n    args.doc = doc;\n    return callHandlers(handlers, args, function () {\n      return post.call(this, args.doc, args.options);\n    });\n  };\n};\n\nwrapperBuilders.get = function (db, get, handlers) {\n  return function(docId, options, callback) {\n    var args = parseBaseArgs(db, this, options, callback);\n    args.docId = docId;\n    return callHandlers(handlers, args, function () {\n      return get.call(this, args.docId, args.options);\n    });\n  };\n};\n\nwrapperBuilders.remove = function (db, remove, handlers) {\n  return function (docOrId, optsOrRev, opts, callback) {\n    var args;\n\n    //originally borrowed from PouchDB\n    if (typeof optsOrRev === 'string') {\n      // id, rev, opts, callback style\n      args = parseBaseArgs(db, this, opts, callback);\n      args.doc = {\n        _id: docOrId,\n        _rev: optsOrRev\n      };\n    } else {\n      // doc, opts, callback style\n      args = parseBaseArgs(db, this, optsOrRev, opts);\n      args.doc = docOrId;\n    }\n\n    return callHandlers(handlers, args, function () {\n      return remove.call(this, args.doc, args.options);\n    });\n  };\n};\n\nwrapperBuilders.bulkDocs = function (db, bulkDocs, handlers) {\n  return function (docs, options, callback) {\n    var args = parseBaseArgs(db, this, options, callback);\n    //support the deprecated signature.\n    if ('new_edits' in docs) {\n      args.options.new_edits = docs.new_edits;\n    }\n    args.docs = docs.docs || docs;\n    return callHandlers(handlers, args, function () {\n      return bulkDocs.call(this, args.docs, args.options);\n    });\n  };\n};\n\nwrapperBuilders.allDocs = function (db, allDocs, handlers) {\n  return function (options, callback) {\n    var args = parseBaseArgs(db, this, options, callback);\n    return callHandlers(handlers, args, makeCallWithOptions(allDocs, args));\n  };\n};\n\nwrapperBuilders.changes = function (db, changes, handlers) {\n  return function (options, callback) {\n    //the callback argument is no longer documented. (And deprecated?)\n    var args = parseBaseArgs(db, this, options, callback);\n    return callHandlers(handlers, args, makeCallWithOptions(changes, args));\n  };\n};\n\nwrapperBuilders.sync = function (db, replicate, handlers) {\n  return function (url, options, callback) {\n    var args = parseBaseArgs(db, this, options, callback);\n    args.url = url;\n    return callHandlers(handlers, args, function () {\n      return replicate.call(this, args.url, args.options);\n    });\n  };\n};\n\nwrapperBuilders[\"replicate.from\"] = wrapperBuilders.sync;\nwrapperBuilders[\"replicate.to\"] = wrapperBuilders.sync;\n\nwrapperBuilders.putAttachment = function (db, putAttachment, handlers) {\n  return function (docId, attachmentId, rev, doc, type, options, callback) {\n    //options is not an 'official' argument. But some plug-ins need it\n    //and maybe (?) also the http adapter.\n\n    //valid calls:\n    //- \"id\", \"aid\", \"rev\", new Blob(), \"text/plain\", {}, function () {}\n    //- \"id\", \"aid\", new Blob(), \"text/plain\", {}, function () {}\n    //- \"id\", \"aid\", new Blob(), \"text/plain\"\n    var args;\n    if (typeof type === \"string\") {\n      //rev is specified\n      args = parseBaseArgs(db, this, options, callback);\n      args.rev = rev;\n      args.doc = doc;\n      args.type = type;\n    } else {\n      //rev is unspecified\n      args = parseBaseArgs(db, this, type, options);\n      args.rev = null;\n      args.doc = rev;\n      args.type = doc;\n    }\n    //fixed arguments\n    args.docId = docId;\n    args.attachmentId = attachmentId;\n\n    return callHandlers(handlers, args, function () {\n      return putAttachment.call(this, args.docId, args.attachmentId, args.rev, args.doc, args.type);\n    });\n  };\n};\n\nwrapperBuilders.getAttachment = function (db, getAttachment, handlers) {\n  return function (docId, attachmentId, options, callback) {\n    var args = parseBaseArgs(db, this, options, callback);\n    args.docId = docId;\n    args.attachmentId = attachmentId;\n    return callHandlers(handlers, args, function () {\n      return getAttachment.call(this, args.docId, args.attachmentId, args.options);\n    });\n  };\n};\n\nwrapperBuilders.removeAttachment = function (db, removeAttachment, handlers) {\n  return function (docId, attachmentId, rev, options, callback) {\n    //see note on the options argument at putAttachment.\n    var args = parseBaseArgs(db, this, options, callback);\n    args.docId = docId;\n    args.attachmentId = attachmentId;\n    args.rev = rev;\n    return callHandlers(handlers, args, function () {\n      return removeAttachment.call(this, args.docId, args.attachmentId, args.rev);\n    });\n  };\n};\n\nwrapperBuilders.query = function (db, query, handlers) {\n  return function (fun, options, callback) {\n    var args = parseBaseArgs(db, this, options, callback);\n    args.fun = fun;\n    return callHandlers(handlers, args, function () {\n      return query.call(this, args.fun, args.options);\n    });\n  };\n};\n\nwrapperBuilders.viewCleanup = function (db, viewCleanup, handlers) {\n  return function (options, callback) {\n    var args = parseBaseArgs(db, this, options, callback);\n    return callHandlers(handlers, args, makeCallWithOptions(viewCleanup, args));\n  };\n};\n\nwrapperBuilders.info = function (db, info, handlers) {\n  return function (options, callback) {\n    //see note on the options argument at putAttachment.\n    var args = parseBaseArgs(db, this, options, callback);\n    return callHandlers(handlers, args, makeCall(info));\n  };\n};\n\nwrapperBuilders.compact = function (db, compact, handlers) {\n  return function (options, callback) {\n    var args = parseBaseArgs(db, this, options, callback);\n    return callHandlers(handlers, args, makeCallWithOptions(compact, args));\n  };\n};\n\nwrapperBuilders.revsDiff = function (db, revsDiff, handlers) {\n  return function (diff, options, callback) {\n    //see note on the options argument at putAttachment.\n    var args = parseBaseArgs(db, this, options, callback);\n    args.diff = diff;\n    return callHandlers(handlers, args, function () {\n      return revsDiff.call(this, args.diff);\n    });\n  };\n};\n\n//Plug-in wrapperBuilders; only of the plug-ins for which a wrapper\n//has been necessary.\n\nwrapperBuilders.list = function (db, orig, handlers) {\n  return function (path, options, callback) {\n    var args = parseBaseArgs(db, this, options, callback);\n    args.path = path;\n\n    return callHandlers(handlers, args, function () {\n      return orig.call(this, args.path, args.options);\n    });\n  };\n};\n\nwrapperBuilders.rewriteResultRequestObject = wrapperBuilders.list;\nwrapperBuilders.show = wrapperBuilders.list;\nwrapperBuilders.update = wrapperBuilders.list;\n\nwrapperBuilders.getSecurity = function (db, getSecurity, handlers) {\n  return function (options, callback) {\n    var args = parseBaseArgs(db, this, options, callback);\n    return callHandlers(handlers, args, makeCallWithOptions(getSecurity, args));\n  };\n};\n\nwrapperBuilders.putSecurity = function (db, putSecurity, handlers) {\n  return function (secObj, options, callback) {\n    //see note on the options argument at putAttachment.\n    var args = parseBaseArgs(db, this, options, callback);\n    args.secObj = secObj;\n    return callHandlers(handlers, args, function () {\n      return putSecurity.call(this, args.secObj);\n    });\n  };\n};\n\n//static\nvar staticWrapperBuilders = {};\n\nstaticWrapperBuilders.new = function (PouchDB, construct, handlers) {\n  return function (name, options, callback) {\n    var args;\n    if (typeof name === \"object\") {\n      args = parseBaseArgs(PouchDB, this, name, options);\n    } else {\n      args = parseBaseArgs(PouchDB, this, options, callback);\n      args.options.name = name;\n    }\n    return callHandlers(handlers, args, function () {\n      return construct.call(this, args.options);\n    });\n  };\n};\n\nstaticWrapperBuilders.destroy = function (PouchDB, destroy, handlers) {\n  return function (name, options, callback) {\n    var args;\n    if (typeof name === \"object\") {\n      args = parseBaseArgs(PouchDB, this, name, options);\n    } else {\n      args = parseBaseArgs(PouchDB, this, options, callback);\n      args.options.name = name;\n    }\n    if (args.options.internal) {\n      return destroy.apply(PouchDB, arguments);\n    }\n    return callHandlers(handlers, args, function () {\n      var name = args.options.name;\n      delete args.options.name;\n\n      return destroy.call(this, name, args.options);\n    });\n  };\n};\n\nstaticWrapperBuilders.replicate = function (PouchDB, replicate, handlers) {\n  return function (source, target, options, callback) {\n    //no callback\n    var args = parseBaseArgs(PouchDB, this, options, callback);\n    args.source = source;\n    args.target = target;\n    return callHandlers(handlers, args, function () {\n      return replicate.call(this, args.source, args.target, args.options);\n    });\n  };\n};\n\nstaticWrapperBuilders.allDbs = function (PouchDB, allDbs, handlers) {\n  return function (options, callback) {\n    var args = parseBaseArgs(PouchDB, this, options, callback);\n    return callHandlers(handlers, args, makeCall(allDbs));\n  };\n};\n\n//Wrap .plugin()? .on()? .defaults()? No use case yet, but it's\n//possible...\n\nfunction parseBaseArgs(thisVal1, thisVal2, options, callback) {\n  if (typeof options === \"function\") {\n    callback = options;\n    options = {};\n  }\n  return {\n    base: thisVal1 || thisVal2,\n    db: thisVal1 || thisVal2, //backwards compatibility\n    options: options || {},\n    callback: callback\n  };\n}\n\nfunction callHandlers(handlers, args, method) {\n  var callback = args.callback;\n  delete args.callback;\n\n  //build a chain of handlers: the bottom handler calls the 'real'\n  //method, the other handlers call other handlers.\n  method = method.bind(args.base);\n  for (var i = handlers.length - 1; i >= 0; i -= 1) {\n    method = handlers[i].bind(null, method, args);\n  }\n  //start running the chain.\n  var promise = method();\n  nodify(promise, callback);\n  return promise;\n}\n\nfunction makeCall(func) {\n  return function () {\n    return func.call(this);\n  };\n}\n\nfunction makeCallWithOptions(func, args) {\n  return function () {\n    return func.call(this, args.options);\n  };\n}\n\nexports.uninstallWrapperMethods = function (db, handlers) {\n  uninstallWrappers(db, handlers);\n};\n\nexports.uninstallStaticWrapperMethods = function (PouchDB, handlers) {\n  uninstallWrappers(PouchDB, handlers);\n};\n\nfunction uninstallWrappers(base, handlers) {\n  for (var name in handlers) {\n    if (!handlers.hasOwnProperty(name)) {\n      continue;\n    }\n    var info = getBaseAndName(base, name);\n    var wrapper = info.base[info.name];\n    if (typeof wrapper === \"undefined\") {\n      //method doesn't exist, so was never wrapped in the first place.\n      continue;\n    }\n\n    var idx;\n    try {\n      idx = wrapper._handlers.indexOf(handlers[name]);\n    } catch (err) {\n      idx = -1;\n    }\n    if (idx === -1) {\n      throw new Error(\"Wrapper method for '\" + name + \"' not installed: \" + handlers[name]);\n    }\n    wrapper._handlers.splice(idx, 1);\n    if (!wrapper._handlers.length) {\n      //fall back to the original on the prototype.\n      delete info.base[info.name];\n      if (info.base[info.name] !== wrapper._original) {\n        //nothing or something unexpected was on the prototype. (E.g.\n        //replicate.to). Reset the original manually.\n        info.base[info.name] = wrapper._original;\n      }\n    }\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/pouchdb-wrappers/index.js?");

/***/ }),

/***/ "./node_modules/promise-nodify/index.js":
/*!**********************************************!*\
  !*** ./node_modules/promise-nodify/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\n  Copyright 2013-2014, Marten de Vries\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n*/\n\n\n\nmodule.exports = function nodify(promise, callback) {\n  if (typeof callback === \"function\") {\n    promise.then(function (resp) {\n      callback(null, resp);\n    }, function (err) {\n      callback(err, null);\n    });\n  }\n};\n\n\n//# sourceURL=webpack:///./node_modules/promise-nodify/index.js?");

/***/ }),

/***/ "./node_modules/transform-pouch/index.js":
/*!***********************************************!*\
  !*** ./node_modules/transform-pouch/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {\n\nvar Promise = __webpack_require__(/*! lie */ \"./node_modules/lie/lib/index.js\");\nvar utils = __webpack_require__(/*! ./pouch-utils */ \"./node_modules/transform-pouch/pouch-utils.js\");\nvar wrappers = __webpack_require__(/*! pouchdb-wrappers */ \"./node_modules/pouchdb-wrappers/index.js\");\nvar immediate = __webpack_require__(/*! immediate */ \"./node_modules/immediate/lib/browser.js\");\n\nfunction isntInternalKey(key) {\n  return key[0] !== '_';\n}\n\nfunction isUntransformable(doc) {\n  var isLocal = typeof doc._id === 'string' && utils.isLocalId(doc._id);\n\n  if (isLocal) {\n    return true;\n  }\n\n  if (doc._deleted) {\n    return Object.keys(doc).filter(isntInternalKey).length === 0;\n  }\n\n  return false;\n}\n\n// api.filter provided for backwards compat with the old \"filter-pouch\"\nexports.transform = exports.filter = function transform(config) {\n  var db = this;\n\n  var incoming = function (doc) {\n    if (!isUntransformable(doc) && config.incoming) {\n      return config.incoming(utils.clone(doc));\n    }\n    return doc;\n  };\n  var outgoing = function (doc) {\n    if (!isUntransformable(doc) && config.outgoing) {\n      return config.outgoing(utils.clone(doc));\n    }\n    return doc;\n  };\n\n  var handlers = {};\n\n  if (db.type() === 'http') {\n    handlers.query = function (orig) {\n      var none = {};\n      return orig().then(function (res) {\n        return utils.Promise.all(res.rows.map(function (row) {\n          if (row.doc) {\n            return outgoing(row.doc);\n          }\n          return none;\n        })).then(function (resp) {\n          resp.forEach(function (doc, i) {\n            if (doc === none) {\n              return;\n            }\n            res.rows[i].doc = doc;\n          });\n          return res;\n        });\n      });\n    };\n  }\n\n  handlers.get = function (orig) {\n    return orig().then(function (res) {\n      if (Array.isArray(res)) {\n        var none = {};\n        // open_revs style, it's a list of docs\n        return utils.Promise.all(res.map(function (row) {\n          if (row.ok) {\n            return outgoing(row.ok);\n          }\n          return none;\n        })).then(function (resp) {\n          resp.forEach(function (doc, i) {\n            if (doc === none) {\n              return;\n            }\n            res[i].ok = doc;\n          });\n          return res;\n        });\n      } else {\n        return outgoing(res);\n      }\n    });\n  };\n\n  handlers.bulkDocs = function (orig, args) {\n    for (var i = 0; i < args.docs.length; i++) {\n      args.docs[i] = incoming(args.docs[i]);\n    }\n    return Promise.all(args.docs).then(function (docs) {\n      args.docs = docs;\n      return orig();\n    });\n  };\n\n  handlers.allDocs = function (orig) {\n    return orig().then(function (res) {\n      var none = {};\n      return utils.Promise.all(res.rows.map(function (row) {\n        if (row.doc) {\n          return outgoing(row.doc);\n        }\n        return none;\n      })).then(function (resp) {\n        resp.forEach(function (doc, i) {\n          if (doc === none) {\n            return;\n          }\n          res.rows[i].doc = doc;\n        });\n        return res;\n      });\n    });\n  };\n\n  handlers.changes = function (orig) {\n    function modifyChange(change) {\n      if (change.doc) {\n        return utils.Promise.resolve(outgoing(change.doc)).then(function (doc) {\n          change.doc = doc;\n          return change;\n        });\n      }\n      return utils.Promise.resolve(change);\n    }\n\n    function modifyChanges(res) {\n      if (res.results) {\n        return utils.Promise.all(res.results.map(modifyChange)).then(function (results) {\n          res.results = results;\n          return res;\n        });\n      }\n      return utils.Promise.resolve(res);\n    }\n\n    var changes = orig();\n    // override some events\n    var origOn = changes.on;\n    changes.on = function (event, listener) {\n      if (event === 'change') {\n        return origOn.apply(changes, [event, function (change) {\n          modifyChange(change).then(function (resp) {\n            immediate(function () {\n              listener(resp);\n            });\n          });\n        }]);\n      } else if (event === 'complete') {\n        return origOn.apply(changes, [event, function (res) {\n          modifyChanges(res).then(function (resp) {\n            process.nextTick(function () {\n              listener(resp);\n            });\n          });\n        }]);\n      }\n      return origOn.apply(changes, [event, listener]);\n    };\n\n    var origThen = changes.then;\n    changes.then = function (resolve, reject) {\n      return origThen.apply(changes, [function (res) {\n        return modifyChanges(res).then(resolve, reject);\n      }, reject]);\n    };\n    return changes;\n  };\n  wrappers.installWrapperMethods(db, handlers);\n};\n\n/* istanbul ignore next */\nif (typeof window !== 'undefined' && window.PouchDB) {\n  window.PouchDB.plugin(exports);\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/transform-pouch/index.js?");

/***/ }),

/***/ "./node_modules/transform-pouch/node_modules/inherits/inherits_browser.js":
/*!********************************************************************************!*\
  !*** ./node_modules/transform-pouch/node_modules/inherits/inherits_browser.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/transform-pouch/node_modules/inherits/inherits_browser.js?");

/***/ }),

/***/ "./node_modules/transform-pouch/node_modules/pouchdb-promise/lib/index.js":
/*!********************************************************************************!*\
  !*** ./node_modules/transform-pouch/node_modules/pouchdb-promise/lib/index.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar lie = _interopDefault(__webpack_require__(/*! lie */ \"./node_modules/lie/lib/index.js\"));\n\n/* istanbul ignore next */\nvar PouchPromise = typeof Promise === 'function' ? Promise : lie;\n\nmodule.exports = PouchPromise;\n\n//# sourceURL=webpack:///./node_modules/transform-pouch/node_modules/pouchdb-promise/lib/index.js?");

/***/ }),

/***/ "./node_modules/transform-pouch/pouch-utils.js":
/*!*****************************************************!*\
  !*** ./node_modules/transform-pouch/pouch-utils.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {\n\nvar Promise = __webpack_require__(/*! pouchdb-promise */ \"./node_modules/transform-pouch/node_modules/pouchdb-promise/lib/index.js\");\n/* istanbul ignore next */\nexports.once = function (fun) {\n  var called = false;\n  return exports.getArguments(function (args) {\n    if (called) {\n      console.trace();\n      throw new Error('once called  more than once');\n    } else {\n      called = true;\n      fun.apply(this, args);\n    }\n  });\n};\n/* istanbul ignore next */\nexports.getArguments = function (fun) {\n  return function () {\n    var len = arguments.length;\n    var args = new Array(len);\n    var i = -1;\n    while (++i < len) {\n      args[i] = arguments[i];\n    }\n    return fun.call(this, args);\n  };\n};\n/* istanbul ignore next */\nexports.toPromise = function (func) {\n  //create the function we will be returning\n  return exports.getArguments(function (args) {\n    var self = this;\n    var tempCB = (typeof args[args.length - 1] === 'function') ? args.pop() : false;\n    // if the last argument is a function, assume its a callback\n    var usedCB;\n    if (tempCB) {\n      // if it was a callback, create a new callback which calls it,\n      // but do so async so we don't trap any errors\n      usedCB = function (err, resp) {\n        process.nextTick(function () {\n          tempCB(err, resp);\n        });\n      };\n    }\n    var promise = new Promise(function (fulfill, reject) {\n      try {\n        var callback = exports.once(function (err, mesg) {\n          if (err) {\n            reject(err);\n          } else {\n            fulfill(mesg);\n          }\n        });\n        // create a callback for this invocation\n        // apply the function in the orig context\n        args.push(callback);\n        func.apply(self, args);\n      } catch (e) {\n        reject(e);\n      }\n    });\n    // if there is a callback, call it back\n    if (usedCB) {\n      promise.then(function (result) {\n        usedCB(null, result);\n      }, usedCB);\n    }\n    promise.cancel = function () {\n      return this;\n    };\n    return promise;\n  });\n};\n\nexports.inherits = __webpack_require__(/*! inherits */ \"./node_modules/transform-pouch/node_modules/inherits/inherits_browser.js\");\nexports.Promise = Promise;\nexports.extend = __webpack_require__(/*! pouchdb-extend */ \"./node_modules/pouchdb-extend/index.js\");\nexports.clone = function (obj) {\n  return exports.extend(true, {}, obj);\n};\n\nexports.isLocalId = function (id) {\n  return (/^_local/).test(id);\n};\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/transform-pouch/pouch-utils.js?");

/***/ })

}]);